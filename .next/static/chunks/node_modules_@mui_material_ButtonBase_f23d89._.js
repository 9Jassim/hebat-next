(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@mui_material_ButtonBase_f23d89._.js", {

"[project]/node_modules/@mui/material/ButtonBase/touchRippleClasses.js [client] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports, t: require }) { !function() {

"use strict";
var _interopRequireDefault = __turbopack_require__("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [client] (ecmascript)").default;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
exports.getTouchRippleUtilityClass = getTouchRippleUtilityClass;
var _generateUtilityClasses = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@mui/utils/generateUtilityClasses/index.js [client] (ecmascript)"));
var _generateUtilityClass = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@mui/utils/generateUtilityClass/index.js [client] (ecmascript)"));
function getTouchRippleUtilityClass(slot) {
    return (0, _generateUtilityClass.default)('MuiTouchRipple', slot);
}
const touchRippleClasses = (0, _generateUtilityClasses.default)('MuiTouchRipple', [
    'root',
    'ripple',
    'rippleVisible',
    'ripplePulsate',
    'child',
    'childLeaving',
    'childPulsate'
]);
var _default = exports.default = touchRippleClasses;

}.call(this) }),
"[project]/node_modules/@mui/material/ButtonBase/buttonBaseClasses.js [client] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports, t: require }) { !function() {

"use strict";
var _interopRequireDefault = __turbopack_require__("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [client] (ecmascript)").default;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
exports.getButtonBaseUtilityClass = getButtonBaseUtilityClass;
var _generateUtilityClasses = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@mui/utils/generateUtilityClasses/index.js [client] (ecmascript)"));
var _generateUtilityClass = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@mui/utils/generateUtilityClass/index.js [client] (ecmascript)"));
function getButtonBaseUtilityClass(slot) {
    return (0, _generateUtilityClass.default)('MuiButtonBase', slot);
}
const buttonBaseClasses = (0, _generateUtilityClasses.default)('MuiButtonBase', [
    'root',
    'disabled',
    'focusVisible'
]);
var _default = exports.default = buttonBaseClasses;

}.call(this) }),
"[project]/node_modules/@mui/material/ButtonBase/Ripple.js [client] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports, t: require }) { !function() {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
"use strict";
'use client';
var _interopRequireDefault = __turbopack_require__("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [client] (ecmascript)").default;
var _interopRequireWildcard = __turbopack_require__("[project]/node_modules/@babel/runtime/helpers/interopRequireWildcard.js [client] (ecmascript)").default;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var React = _interopRequireWildcard(__turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js [client] (ecmascript)"));
var _propTypes = _interopRequireDefault(__turbopack_require__("[project]/node_modules/prop-types/index.js [client] (ecmascript)"));
var _clsx = _interopRequireDefault(__turbopack_require__("[project]/node_modules/clsx/dist/clsx.js [client] (ecmascript)"));
var _jsxRuntime = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [client] (ecmascript)");
/**
 * @ignore - internal component.
 */ function Ripple(props) {
    const { className, classes, pulsate = false, rippleX, rippleY, rippleSize, in: inProp, onExited, timeout } = props;
    const [leaving, setLeaving] = React.useState(false);
    const rippleClassName = (0, _clsx.default)(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
    const rippleStyles = {
        width: rippleSize,
        height: rippleSize,
        top: -(rippleSize / 2) + rippleY,
        left: -(rippleSize / 2) + rippleX
    };
    const childClassName = (0, _clsx.default)(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
    if (!inProp && !leaving) {
        setLeaving(true);
    }
    React.useEffect(()=>{
        if (!inProp && onExited != null) {
            // react-transition-group#onExited
            const timeoutId = setTimeout(onExited, timeout);
            return ()=>{
                clearTimeout(timeoutId);
            };
        }
        return undefined;
    }, [
        onExited,
        inProp,
        timeout
    ]);
    return /*#__PURE__*/ (0, _jsxRuntime.jsx)("span", {
        className: rippleClassName,
        style: rippleStyles,
        children: /*#__PURE__*/ (0, _jsxRuntime.jsx)("span", {
            className: childClassName
        })
    });
}
("TURBOPACK compile-time truthy", 1) ? Ripple.propTypes /* remove-proptypes */  = {
    /**
   * Override or extend the styles applied to the component.
   */ classes: _propTypes.default.object.isRequired,
    className: _propTypes.default.string,
    /**
   * @ignore - injected from TransitionGroup
   */ in: _propTypes.default.bool,
    /**
   * @ignore - injected from TransitionGroup
   */ onExited: _propTypes.default.func,
    /**
   * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.
   */ pulsate: _propTypes.default.bool,
    /**
   * Diameter of the ripple.
   */ rippleSize: _propTypes.default.number,
    /**
   * Horizontal position of the ripple center.
   */ rippleX: _propTypes.default.number,
    /**
   * Vertical position of the ripple center.
   */ rippleY: _propTypes.default.number,
    /**
   * exit delay
   */ timeout: _propTypes.default.number.isRequired
} : ("TURBOPACK unreachable", undefined);
var _default = exports.default = Ripple;

}.call(this) }),
"[project]/node_modules/@mui/material/ButtonBase/TouchRipple.js [client] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports, t: require }) { !function() {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
"use strict";
'use client';
var _interopRequireDefault = __turbopack_require__("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [client] (ecmascript)").default;
var _interopRequireWildcard = __turbopack_require__("[project]/node_modules/@babel/runtime/helpers/interopRequireWildcard.js [client] (ecmascript)").default;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = exports.TouchRippleRoot = exports.TouchRippleRipple = exports.DELAY_RIPPLE = void 0;
var React = _interopRequireWildcard(__turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js [client] (ecmascript)"));
var _propTypes = _interopRequireDefault(__turbopack_require__("[project]/node_modules/prop-types/index.js [client] (ecmascript)"));
var _reactTransitionGroup = __turbopack_require__("[project]/node_modules/react-transition-group/esm/index.js [client] (ecmascript)");
var _clsx = _interopRequireDefault(__turbopack_require__("[project]/node_modules/clsx/dist/clsx.js [client] (ecmascript)"));
var _useTimeout = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@mui/utils/useTimeout/index.js [client] (ecmascript)"));
var _zeroStyled = __turbopack_require__("[project]/node_modules/@mui/material/zero-styled/index.js [client] (ecmascript)");
var _DefaultPropsProvider = __turbopack_require__("[project]/node_modules/@mui/material/DefaultPropsProvider/index.js [client] (ecmascript)");
var _Ripple = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@mui/material/ButtonBase/Ripple.js [client] (ecmascript)"));
var _touchRippleClasses = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@mui/material/ButtonBase/touchRippleClasses.js [client] (ecmascript)"));
var _jsxRuntime = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [client] (ecmascript)");
const DURATION = 550;
const DELAY_RIPPLE = exports.DELAY_RIPPLE = 80;
const enterKeyframe = (0, _zeroStyled.keyframes)`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`;
const exitKeyframe = (0, _zeroStyled.keyframes)`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`;
const pulsateKeyframe = (0, _zeroStyled.keyframes)`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`;
const TouchRippleRoot = exports.TouchRippleRoot = (0, _zeroStyled.styled)('span', {
    name: 'MuiTouchRipple',
    slot: 'Root'
})({
    overflow: 'hidden',
    pointerEvents: 'none',
    position: 'absolute',
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: 'inherit'
});
// This `styled()` function invokes keyframes. `styled-components` only supports keyframes
// in string templates. Do not convert these styles in JS object as it will break.
const TouchRippleRipple = exports.TouchRippleRipple = (0, _zeroStyled.styled)(_Ripple.default, {
    name: 'MuiTouchRipple',
    slot: 'Ripple'
})`
  opacity: 0;
  position: absolute;

  &.${_touchRippleClasses.default.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${enterKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${(param)=>{
    let { theme } = param;
    return theme.transitions.easing.easeInOut;
}};
  }

  &.${_touchRippleClasses.default.ripplePulsate} {
    animation-duration: ${(param)=>{
    let { theme } = param;
    return theme.transitions.duration.shorter;
}}ms;
  }

  & .${_touchRippleClasses.default.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${_touchRippleClasses.default.childLeaving} {
    opacity: 0;
    animation-name: ${exitKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${(param)=>{
    let { theme } = param;
    return theme.transitions.easing.easeInOut;
}};
  }

  & .${_touchRippleClasses.default.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${pulsateKeyframe};
    animation-duration: 2500ms;
    animation-timing-function: ${(param)=>{
    let { theme } = param;
    return theme.transitions.easing.easeInOut;
}};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`;
/**
 * @ignore - internal component.
 *
 * TODO v5: Make private
 */ const TouchRipple = /*#__PURE__*/ React.forwardRef(function TouchRipple(inProps, ref) {
    const props = (0, _DefaultPropsProvider.useDefaultProps)({
        props: inProps,
        name: 'MuiTouchRipple'
    });
    const { center: centerProp = false, classes = {}, className, ...other } = props;
    const [ripples, setRipples] = React.useState([]);
    const nextKey = React.useRef(0);
    const rippleCallback = React.useRef(null);
    React.useEffect(()=>{
        if (rippleCallback.current) {
            rippleCallback.current();
            rippleCallback.current = null;
        }
    }, [
        ripples
    ]);
    // Used to filter out mouse emulated events on mobile.
    const ignoringMouseDown = React.useRef(false);
    // We use a timer in order to only show the ripples for touch "click" like events.
    // We don't want to display the ripple for touch scroll events.
    const startTimer = (0, _useTimeout.default)();
    // This is the hook called once the previous timeout is ready.
    const startTimerCommit = React.useRef(null);
    const container = React.useRef(null);
    const startCommit = React.useCallback((params)=>{
        const { pulsate, rippleX, rippleY, rippleSize, cb } = params;
        setRipples((oldRipples)=>[
                ...oldRipples,
                /*#__PURE__*/ (0, _jsxRuntime.jsx)(TouchRippleRipple, {
                    classes: {
                        ripple: (0, _clsx.default)(classes.ripple, _touchRippleClasses.default.ripple),
                        rippleVisible: (0, _clsx.default)(classes.rippleVisible, _touchRippleClasses.default.rippleVisible),
                        ripplePulsate: (0, _clsx.default)(classes.ripplePulsate, _touchRippleClasses.default.ripplePulsate),
                        child: (0, _clsx.default)(classes.child, _touchRippleClasses.default.child),
                        childLeaving: (0, _clsx.default)(classes.childLeaving, _touchRippleClasses.default.childLeaving),
                        childPulsate: (0, _clsx.default)(classes.childPulsate, _touchRippleClasses.default.childPulsate)
                    },
                    timeout: DURATION,
                    pulsate: pulsate,
                    rippleX: rippleX,
                    rippleY: rippleY,
                    rippleSize: rippleSize
                }, nextKey.current)
            ]);
        nextKey.current += 1;
        rippleCallback.current = cb;
    }, [
        classes
    ]);
    const start = React.useCallback(function() {
        let event = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, cb = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ()=>{};
        const { pulsate = false, center = centerProp || options.pulsate, fakeElement = false // For test purposes
         } = options;
        if (event?.type === 'mousedown' && ignoringMouseDown.current) {
            ignoringMouseDown.current = false;
            return;
        }
        if (event?.type === 'touchstart') {
            ignoringMouseDown.current = true;
        }
        const element = fakeElement ? null : container.current;
        const rect = element ? element.getBoundingClientRect() : {
            width: 0,
            height: 0,
            left: 0,
            top: 0
        };
        // Get the size of the ripple
        let rippleX;
        let rippleY;
        let rippleSize;
        if (center || event === undefined || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
            rippleX = Math.round(rect.width / 2);
            rippleY = Math.round(rect.height / 2);
        } else {
            const { clientX, clientY } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
            rippleX = Math.round(clientX - rect.left);
            rippleY = Math.round(clientY - rect.top);
        }
        if (center) {
            rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
            // For some reason the animation is broken on Mobile Chrome if the size is even.
            if (rippleSize % 2 === 0) {
                rippleSize += 1;
            }
        } else {
            const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
            const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
            rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
        }
        // Touche devices
        if (event?.touches) {
            // check that this isn't another touchstart due to multitouch
            // otherwise we will only clear a single timer when unmounting while two
            // are running
            if (startTimerCommit.current === null) {
                // Prepare the ripple effect.
                startTimerCommit.current = ()=>{
                    startCommit({
                        pulsate,
                        rippleX,
                        rippleY,
                        rippleSize,
                        cb
                    });
                };
                // Delay the execution of the ripple effect.
                // We have to make a tradeoff with this delay value.
                startTimer.start(DELAY_RIPPLE, ()=>{
                    if (startTimerCommit.current) {
                        startTimerCommit.current();
                        startTimerCommit.current = null;
                    }
                });
            }
        } else {
            startCommit({
                pulsate,
                rippleX,
                rippleY,
                rippleSize,
                cb
            });
        }
    }, [
        centerProp,
        startCommit,
        startTimer
    ]);
    const pulsate = React.useCallback(()=>{
        start({}, {
            pulsate: true
        });
    }, [
        start
    ]);
    const stop = React.useCallback((event, cb)=>{
        startTimer.clear();
        // The touch interaction occurs too quickly.
        // We still want to show ripple effect.
        if (event?.type === 'touchend' && startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
            startTimer.start(0, ()=>{
                stop(event, cb);
            });
            return;
        }
        startTimerCommit.current = null;
        setRipples((oldRipples)=>{
            if (oldRipples.length > 0) {
                return oldRipples.slice(1);
            }
            return oldRipples;
        });
        rippleCallback.current = cb;
    }, [
        startTimer
    ]);
    React.useImperativeHandle(ref, ()=>({
            pulsate,
            start,
            stop
        }), [
        pulsate,
        start,
        stop
    ]);
    return /*#__PURE__*/ (0, _jsxRuntime.jsx)(TouchRippleRoot, {
        className: (0, _clsx.default)(_touchRippleClasses.default.root, classes.root, className),
        ref: container,
        ...other,
        children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_reactTransitionGroup.TransitionGroup, {
            component: null,
            exit: true,
            children: ripples
        })
    });
});
("TURBOPACK compile-time truthy", 1) ? TouchRipple.propTypes /* remove-proptypes */  = {
    /**
   * If `true`, the ripple starts at the center of the component
   * rather than at the point of interaction.
   */ center: _propTypes.default.bool,
    /**
   * Override or extend the styles applied to the component.
   */ classes: _propTypes.default.object,
    /**
   * @ignore
   */ className: _propTypes.default.string
} : ("TURBOPACK unreachable", undefined);
var _default = exports.default = TouchRipple;

}.call(this) }),
"[project]/node_modules/@mui/material/ButtonBase/ButtonBase.js [client] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports, t: require }) { !function() {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
"use strict";
'use client';
var _interopRequireDefault = __turbopack_require__("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [client] (ecmascript)").default;
var _interopRequireWildcard = __turbopack_require__("[project]/node_modules/@babel/runtime/helpers/interopRequireWildcard.js [client] (ecmascript)").default;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = exports.ButtonBaseRoot = void 0;
var React = _interopRequireWildcard(__turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js [client] (ecmascript)"));
var _propTypes = _interopRequireDefault(__turbopack_require__("[project]/node_modules/prop-types/index.js [client] (ecmascript)"));
var _clsx = _interopRequireDefault(__turbopack_require__("[project]/node_modules/clsx/dist/clsx.js [client] (ecmascript)"));
var _refType = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@mui/utils/refType/index.js [client] (ecmascript)"));
var _elementTypeAcceptingRef = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@mui/utils/elementTypeAcceptingRef/index.js [client] (ecmascript)"));
var _composeClasses = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@mui/utils/composeClasses/index.js [client] (ecmascript)"));
var _isFocusVisible = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@mui/utils/isFocusVisible/index.js [client] (ecmascript)"));
var _zeroStyled = __turbopack_require__("[project]/node_modules/@mui/material/zero-styled/index.js [client] (ecmascript)");
var _DefaultPropsProvider = __turbopack_require__("[project]/node_modules/@mui/material/DefaultPropsProvider/index.js [client] (ecmascript)");
var _useForkRef = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@mui/material/utils/useForkRef.js [client] (ecmascript)"));
var _useEventCallback = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@mui/material/utils/useEventCallback.js [client] (ecmascript)"));
var _useLazyRipple = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@mui/material/useLazyRipple/index.js [client] (ecmascript)"));
var _TouchRipple = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@mui/material/ButtonBase/TouchRipple.js [client] (ecmascript)"));
var _buttonBaseClasses = _interopRequireWildcard(__turbopack_require__("[project]/node_modules/@mui/material/ButtonBase/buttonBaseClasses.js [client] (ecmascript)"));
var _jsxRuntime = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [client] (ecmascript)");
const useUtilityClasses = (ownerState)=>{
    const { disabled, focusVisible, focusVisibleClassName, classes } = ownerState;
    const slots = {
        root: [
            'root',
            disabled && 'disabled',
            focusVisible && 'focusVisible'
        ]
    };
    const composedClasses = (0, _composeClasses.default)(slots, _buttonBaseClasses.getButtonBaseUtilityClass, classes);
    if (focusVisible && focusVisibleClassName) {
        composedClasses.root += ` ${focusVisibleClassName}`;
    }
    return composedClasses;
};
const ButtonBaseRoot = exports.ButtonBaseRoot = (0, _zeroStyled.styled)('button', {
    name: 'MuiButtonBase',
    slot: 'Root'
})({
    display: 'inline-flex',
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative',
    boxSizing: 'border-box',
    WebkitTapHighlightColor: 'transparent',
    backgroundColor: 'transparent',
    // Reset default value
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    border: 0,
    margin: 0,
    // Remove the margin in Safari
    borderRadius: 0,
    padding: 0,
    // Remove the padding in Firefox
    cursor: 'pointer',
    userSelect: 'none',
    verticalAlign: 'middle',
    MozAppearance: 'none',
    // Reset
    WebkitAppearance: 'none',
    // Reset
    textDecoration: 'none',
    // So we take precedent over the style of a native <a /> element.
    color: 'inherit',
    '&::-moz-focus-inner': {
        borderStyle: 'none' // Remove Firefox dotted outline.
    },
    [`&.${_buttonBaseClasses.default.disabled}`]: {
        pointerEvents: 'none',
        // Disable link interactions
        cursor: 'default'
    },
    '@media print': {
        colorAdjust: 'exact'
    }
});
/**
 * `ButtonBase` contains as few styles as possible.
 * It aims to be a simple building block for creating a button.
 * It contains a load of style reset and some focus/ripple logic.
 */ const ButtonBase = /*#__PURE__*/ React.forwardRef(function ButtonBase(inProps, ref) {
    const props = (0, _DefaultPropsProvider.useDefaultProps)({
        props: inProps,
        name: 'MuiButtonBase'
    });
    const { action, centerRipple = false, children, className, component = 'button', disabled = false, disableRipple = false, disableTouchRipple = false, focusRipple = false, focusVisibleClassName, LinkComponent = 'a', onBlur, onClick, onContextMenu, onDragLeave, onFocus, onFocusVisible, onKeyDown, onKeyUp, onMouseDown, onMouseLeave, onMouseUp, onTouchEnd, onTouchMove, onTouchStart, tabIndex = 0, TouchRippleProps, touchRippleRef, type, ...other } = props;
    const buttonRef = React.useRef(null);
    const ripple = (0, _useLazyRipple.default)();
    const handleRippleRef = (0, _useForkRef.default)(ripple.ref, touchRippleRef);
    const [focusVisible, setFocusVisible] = React.useState(false);
    if (disabled && focusVisible) {
        setFocusVisible(false);
    }
    React.useImperativeHandle(action, ()=>({
            focusVisible: ()=>{
                setFocusVisible(true);
                buttonRef.current.focus();
            }
        }), []);
    const enableTouchRipple = ripple.shouldMount && !disableRipple && !disabled;
    React.useEffect(()=>{
        if (focusVisible && focusRipple && !disableRipple) {
            ripple.pulsate();
        }
    }, [
        disableRipple,
        focusRipple,
        focusVisible,
        ripple
    ]);
    const handleMouseDown = useRippleHandler(ripple, 'start', onMouseDown, disableTouchRipple);
    const handleContextMenu = useRippleHandler(ripple, 'stop', onContextMenu, disableTouchRipple);
    const handleDragLeave = useRippleHandler(ripple, 'stop', onDragLeave, disableTouchRipple);
    const handleMouseUp = useRippleHandler(ripple, 'stop', onMouseUp, disableTouchRipple);
    const handleMouseLeave = useRippleHandler(ripple, 'stop', (event)=>{
        if (focusVisible) {
            event.preventDefault();
        }
        if (onMouseLeave) {
            onMouseLeave(event);
        }
    }, disableTouchRipple);
    const handleTouchStart = useRippleHandler(ripple, 'start', onTouchStart, disableTouchRipple);
    const handleTouchEnd = useRippleHandler(ripple, 'stop', onTouchEnd, disableTouchRipple);
    const handleTouchMove = useRippleHandler(ripple, 'stop', onTouchMove, disableTouchRipple);
    const handleBlur = useRippleHandler(ripple, 'stop', (event)=>{
        if (!(0, _isFocusVisible.default)(event.target)) {
            setFocusVisible(false);
        }
        if (onBlur) {
            onBlur(event);
        }
    }, false);
    const handleFocus = (0, _useEventCallback.default)((event)=>{
        // Fix for https://github.com/facebook/react/issues/7769
        if (!buttonRef.current) {
            buttonRef.current = event.currentTarget;
        }
        if ((0, _isFocusVisible.default)(event.target)) {
            setFocusVisible(true);
            if (onFocusVisible) {
                onFocusVisible(event);
            }
        }
        if (onFocus) {
            onFocus(event);
        }
    });
    const isNonNativeButton = ()=>{
        const button = buttonRef.current;
        return component && component !== 'button' && !(button.tagName === 'A' && button.href);
    };
    const handleKeyDown = (0, _useEventCallback.default)((event)=>{
        // Check if key is already down to avoid repeats being counted as multiple activations
        if (focusRipple && !event.repeat && focusVisible && event.key === ' ') {
            ripple.stop(event, ()=>{
                ripple.start(event);
            });
        }
        if (event.target === event.currentTarget && isNonNativeButton() && event.key === ' ') {
            event.preventDefault();
        }
        if (onKeyDown) {
            onKeyDown(event);
        }
        // Keyboard accessibility for non interactive elements
        if (event.target === event.currentTarget && isNonNativeButton() && event.key === 'Enter' && !disabled) {
            event.preventDefault();
            if (onClick) {
                onClick(event);
            }
        }
    });
    const handleKeyUp = (0, _useEventCallback.default)((event)=>{
        // calling preventDefault in keyUp on a <button> will not dispatch a click event if Space is pressed
        // https://codesandbox.io/p/sandbox/button-keyup-preventdefault-dn7f0
        if (focusRipple && event.key === ' ' && focusVisible && !event.defaultPrevented) {
            ripple.stop(event, ()=>{
                ripple.pulsate(event);
            });
        }
        if (onKeyUp) {
            onKeyUp(event);
        }
        // Keyboard accessibility for non interactive elements
        if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === ' ' && !event.defaultPrevented) {
            onClick(event);
        }
    });
    let ComponentProp = component;
    if (ComponentProp === 'button' && (other.href || other.to)) {
        ComponentProp = LinkComponent;
    }
    const buttonProps = {};
    if (ComponentProp === 'button') {
        buttonProps.type = type === undefined ? 'button' : type;
        buttonProps.disabled = disabled;
    } else {
        if (!other.href && !other.to) {
            buttonProps.role = 'button';
        }
        if (disabled) {
            buttonProps['aria-disabled'] = disabled;
        }
    }
    const handleRef = (0, _useForkRef.default)(ref, buttonRef);
    const ownerState = {
        ...props,
        centerRipple,
        component,
        disabled,
        disableRipple,
        disableTouchRipple,
        focusRipple,
        tabIndex,
        focusVisible
    };
    const classes = useUtilityClasses(ownerState);
    return /*#__PURE__*/ (0, _jsxRuntime.jsxs)(ButtonBaseRoot, {
        as: ComponentProp,
        className: (0, _clsx.default)(classes.root, className),
        ownerState: ownerState,
        onBlur: handleBlur,
        onClick: onClick,
        onContextMenu: handleContextMenu,
        onFocus: handleFocus,
        onKeyDown: handleKeyDown,
        onKeyUp: handleKeyUp,
        onMouseDown: handleMouseDown,
        onMouseLeave: handleMouseLeave,
        onMouseUp: handleMouseUp,
        onDragLeave: handleDragLeave,
        onTouchEnd: handleTouchEnd,
        onTouchMove: handleTouchMove,
        onTouchStart: handleTouchStart,
        ref: handleRef,
        tabIndex: disabled ? -1 : tabIndex,
        type: type,
        ...buttonProps,
        ...other,
        children: [
            children,
            enableTouchRipple ? /*#__PURE__*/ (0, _jsxRuntime.jsx)(_TouchRipple.default, {
                ref: handleRippleRef,
                center: centerRipple,
                ...TouchRippleProps
            }) : null
        ]
    });
});
function useRippleHandler(ripple, rippleAction, eventCallback) {
    let skipRippleAction = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    return (0, _useEventCallback.default)((event)=>{
        if (eventCallback) {
            eventCallback(event);
        }
        if (!skipRippleAction) {
            ripple[rippleAction](event);
        }
        return true;
    });
}
("TURBOPACK compile-time truthy", 1) ? ButtonBase.propTypes /* remove-proptypes */  = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
   * A ref for imperative actions.
   * It currently only supports `focusVisible()` action.
   */ action: _refType.default,
    /**
   * If `true`, the ripples are centered.
   * They won't start at the cursor interaction position.
   * @default false
   */ centerRipple: _propTypes.default.bool,
    /**
   * The content of the component.
   */ children: _propTypes.default.node,
    /**
   * Override or extend the styles applied to the component.
   */ classes: _propTypes.default.object,
    /**
   * @ignore
   */ className: _propTypes.default.string,
    /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */ component: _elementTypeAcceptingRef.default,
    /**
   * If `true`, the component is disabled.
   * @default false
   */ disabled: _propTypes.default.bool,
    /**
   * If `true`, the ripple effect is disabled.
   *
   * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
   * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
   * @default false
   */ disableRipple: _propTypes.default.bool,
    /**
   * If `true`, the touch ripple effect is disabled.
   * @default false
   */ disableTouchRipple: _propTypes.default.bool,
    /**
   * If `true`, the base button will have a keyboard focus ripple.
   * @default false
   */ focusRipple: _propTypes.default.bool,
    /**
   * This prop can help identify which element has keyboard focus.
   * The class name will be applied when the element gains the focus through keyboard interaction.
   * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
   * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
   * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
   * if needed.
   */ focusVisibleClassName: _propTypes.default.string,
    /**
   * @ignore
   */ href: _propTypes.default/* @typescript-to-proptypes-ignore */ .any,
    /**
   * The component used to render a link when the `href` prop is provided.
   * @default 'a'
   */ LinkComponent: _propTypes.default.elementType,
    /**
   * @ignore
   */ onBlur: _propTypes.default.func,
    /**
   * @ignore
   */ onClick: _propTypes.default.func,
    /**
   * @ignore
   */ onContextMenu: _propTypes.default.func,
    /**
   * @ignore
   */ onDragLeave: _propTypes.default.func,
    /**
   * @ignore
   */ onFocus: _propTypes.default.func,
    /**
   * Callback fired when the component is focused with a keyboard.
   * We trigger a `onFocus` callback too.
   */ onFocusVisible: _propTypes.default.func,
    /**
   * @ignore
   */ onKeyDown: _propTypes.default.func,
    /**
   * @ignore
   */ onKeyUp: _propTypes.default.func,
    /**
   * @ignore
   */ onMouseDown: _propTypes.default.func,
    /**
   * @ignore
   */ onMouseLeave: _propTypes.default.func,
    /**
   * @ignore
   */ onMouseUp: _propTypes.default.func,
    /**
   * @ignore
   */ onTouchEnd: _propTypes.default.func,
    /**
   * @ignore
   */ onTouchMove: _propTypes.default.func,
    /**
   * @ignore
   */ onTouchStart: _propTypes.default.func,
    /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */ sx: _propTypes.default.oneOfType([
        _propTypes.default.arrayOf(_propTypes.default.oneOfType([
            _propTypes.default.func,
            _propTypes.default.object,
            _propTypes.default.bool
        ])),
        _propTypes.default.func,
        _propTypes.default.object
    ]),
    /**
   * @default 0
   */ tabIndex: _propTypes.default.number,
    /**
   * Props applied to the `TouchRipple` element.
   */ TouchRippleProps: _propTypes.default.object,
    /**
   * A ref that points to the `TouchRipple` element.
   */ touchRippleRef: _propTypes.default.oneOfType([
        _propTypes.default.func,
        _propTypes.default.shape({
            current: _propTypes.default.shape({
                pulsate: _propTypes.default.func.isRequired,
                start: _propTypes.default.func.isRequired,
                stop: _propTypes.default.func.isRequired
            })
        })
    ]),
    /**
   * @ignore
   */ type: _propTypes.default.oneOfType([
        _propTypes.default.oneOf([
            'button',
            'reset',
            'submit'
        ]),
        _propTypes.default.string
    ])
} : ("TURBOPACK unreachable", undefined);
var _default = exports.default = ButtonBase;

}.call(this) }),
"[project]/node_modules/@mui/material/ButtonBase/index.js [client] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_require_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, l: __turbopack_load__, j: __turbopack_dynamic__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports, t: require }) { !function() {

"use strict";
var _interopRequireWildcard = __turbopack_require__("[project]/node_modules/@babel/runtime/helpers/interopRequireWildcard.js [client] (ecmascript)").default;
var _interopRequireDefault = __turbopack_require__("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [client] (ecmascript)").default;
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _exportNames = {
    buttonBaseClasses: true,
    touchRippleClasses: true
};
Object.defineProperty(exports, "buttonBaseClasses", {
    enumerable: true,
    get: function() {
        return _buttonBaseClasses.default;
    }
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _ButtonBase.default;
    }
});
Object.defineProperty(exports, "touchRippleClasses", {
    enumerable: true,
    get: function() {
        return _touchRippleClasses.default;
    }
});
var _ButtonBase = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@mui/material/ButtonBase/ButtonBase.js [client] (ecmascript)"));
var _buttonBaseClasses = _interopRequireWildcard(__turbopack_require__("[project]/node_modules/@mui/material/ButtonBase/buttonBaseClasses.js [client] (ecmascript)"));
Object.keys(_buttonBaseClasses).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _buttonBaseClasses[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _buttonBaseClasses[key];
        }
    });
});
var _touchRippleClasses = _interopRequireWildcard(__turbopack_require__("[project]/node_modules/@mui/material/ButtonBase/touchRippleClasses.js [client] (ecmascript)"));
Object.keys(_touchRippleClasses).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _touchRippleClasses[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _touchRippleClasses[key];
        }
    });
});

}.call(this) }),
}]);

//# sourceMappingURL=node_modules_@mui_material_ButtonBase_f23d89._.js.map